/* -*-c++-*- */
/* osgEarth - Dynamic map generation toolkit for OpenSceneGraph
 * Copyright 2008-2013 Pelican Mapping
 * http://osgearth.org
 *
 * osgEarth is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published by
 * the Free Software Foundation; either version 2 of the License, or
 * (at your option) any later version.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *
 * You should have received a copy of the GNU Lesser General Public License
 * along with this program.  If not, see <http://www.gnu.org/licenses/>
 */

#ifndef OSGEARTHFEATURES_ROOF_BUILDER_H
#define OSGEARTHFEATURES_ROOF_BUILDER_H 1

#include <osgEarthFeatures/Common>
#include <osg/Vec3>
#include <osg/Plane>
#include <osg/Geometry>
#include <vector>

namespace osgEarth { namespace Features 
{
    using namespace osgEarth;
	
	struct SkeletonEvent{
		SkeletonEvent():time(FLT_MAX){};
		enum EventType{EDGE, SPLIT};

		EventType	evtType;
		float		time;
		osg::Vec2	intersection;

		union{
			unsigned int		faceIndex;
			unsigned int		edgeIndex;
		};
	};

	struct RoofFaceEdge{
		RoofFaceEdge(unsigned int _edgeIndex, std::vector<struct RoofFace>& roofFaces, unsigned int _leftFaceIndex, unsigned int _rightFaceIndex);	

		osg::Vec2	getEndPoint();
		void		clipEdgeToOutline(std::vector<struct RoofFace>& roofFaces);
		void		setIntersection(std::vector<RoofFace>& roofFaces, RoofFaceEdge& edge, osg::Vec2 intersection);
		void		clipToEdge(std::vector<RoofFace>& roofFaces, RoofFaceEdge& edge);
		void		clipToEdgeToNeighbors(std::vector<RoofFace>& roofFaces, std::vector<RoofFaceEdge>& faceEdges);

		void		Disable(){bActive = false;}

		unsigned int	edgeIndex;
		unsigned int	leftFaceIndex;
		unsigned int	rightFaceIndex;

		bool			bActive;

		osg::Vec2		vStart;
		osg::Vec2		vDir;
		float			length;
		SkeletonEvent	evt;

		float			createTime;
	};

	struct RoofFace
	{
		RoofFace(unsigned int index, const osg::Vec2& _p1, const osg::Vec2& _p2);
		void		initEdgeData();
		RoofFace&	splitFace(std::vector<struct RoofFace>& roofFaces, osg::Vec2 splitPoint);
		osg::Vec2	getLeftEndPoint();
		osg::Vec2	getRightEndPoint();
		float		getPointDist(osg::Vec2 p);
		void		generateGeometry(osg::Vec3Array* roofVerts, osg::Vec3Array* roofNormals, osg::Vec3Array* roofTexCoords, float texSpanY, float roofStartZ, float roofAngle);
		
		void		setLeftEdgeIndex(unsigned int index){ leftEdgeIndex = index; }
		void		setRightEdgeIndex(unsigned int index){ rightEdgeIndex = index; }

		unsigned int			faceIndex;
		osg::Vec2				p1,p2;
		osg::Vec2				edgeNormal;
		osg::Vec2				edgeDir;
		float					edgeLength;

		std::vector<osg::Vec2> leftEdge;
		std::vector<osg::Vec2> rightEdge;

		unsigned int			leftEdgeIndex;
		unsigned int			rightEdgeIndex;

		osg::Vec2				textureOrigo;
	};

	class OSGEARTHFEATURES_EXPORT RoofBuilder2D
	{
	public:
		RoofBuilder2D(std::vector<osg::Vec3> outline, float roofAngle);
		void	clipEdgesToOutline();
		void	clipEdgesToEdges();
		int		getMinEdgeIndex();

		void	edgeEvent(RoofFaceEdge& edge);
		void	splitEvent(RoofFaceEdge& edge);

		void	generateRoofGeometry(osg::Geometry* roofGeometry, osg::Vec3Array*  roofVerts, osg::Vec3Array* roofNormals, osg::Vec3Array* roofTexcoords, float roofTexSpanY, float roofAngle);

		std::vector<RoofFace> roofFaces;
		std::vector<RoofFaceEdge> faceEdges;
		float	roofStartZ;

		osg::Vec2 vMin, vMax;
	};

} } // namespace osgEarth::Features

#endif // OSGEARTHFEATURES_ROOF_BUILDER_H